    Checking rs_utils v0.1.0 (/Users/will/Code/rust-book-backend/notebooks/rs_utils)
error[E0423]: expected function, tuple struct or tuple variant, found struct `chrono::DateTime`
  --> src/analysis.rs:13:10
   |
13 | #[derive(Deserialize)]
   |          ^^^^^^^^^^^ help: use struct literal syntax instead: `chrono::DateTime { datetime: val, offset: val }`
   |
  ::: /Users/will/.cargo/registry/src/index.crates.io-6f17d22bba15001f/chrono-0.4.31/src/datetime/mod.rs:86:1
   |
86 | pub struct DateTime<Tz: TimeZone> {
   | --------------------------------- `chrono::DateTime` defined here
   |
   = note: this error originates in the derive macro `Deserialize` (in Nightly builds, run with -Z macro-backtrace for more info)
warning: unused import: `Serialize`
 --> src/analysis.rs:8:26
  |
8 | use serde::{Deserialize, Serialize};
  |                          ^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default
For more information about this error, try `rustc --explain E0423`.

#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
use pyo3::prelude::*;
mod analysis {
    use std::io::Read;
    use anyhow::{Context, Result};
    use arrayvec::ArrayString;
    use flate2::read::ZlibDecoder;
    use pyo3::prelude::*;
    use rayon::prelude::*;
    use serde::{Deserialize, Serialize};
    use smallvec::SmallVec;
    type DateTime = chrono::DateTime<chrono::Utc>;
    #[serde(remote = "chrono::DateTime<chrono::Utc>")]
    struct UtcMillis(usize);
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        impl<'de> UtcMillis {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<chrono::DateTime<chrono::Utc>, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<chrono::DateTime<chrono::Utc>>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = chrono::DateTime<chrono::Utc>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "tuple struct DateTime",
                        )
                    }
                    #[inline]
                    fn visit_newtype_struct<__E>(
                        self,
                        __e: __E,
                    ) -> _serde::__private::Result<Self::Value, __E::Error>
                    where
                        __E: _serde::Deserializer<'de>,
                    {
                        let __field0: usize = <usize as _serde::Deserialize>::deserialize(__e)?;
                        _serde::__private::Ok(chrono::DateTime::<chrono::Utc>(__field0))
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 =
                            match _serde::de::SeqAccess::next_element::<usize>(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"tuple struct DateTime with 1 element",
                                        ),
                                    )
                                }
                            };
                        _serde::__private::Ok(chrono::DateTime::<chrono::Utc>(__field0))
                    }
                }
                _serde::Deserializer::deserialize_newtype_struct(
                    __deserializer,
                    "UtcMillis",
                    __Visitor {
                        marker: _serde::__private::PhantomData::<chrono::DateTime<chrono::Utc>>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    impl TryFrom<UtcMillis> for DateTime {
        type Error = &'static str;
        fn try_from(value: UtcMillis) -> Result<Self, Self::Error> {
            chrono::DateTime::from_timestamp(
                (value.0 / 1000) as i64,
                ((value.0 % 1000) * 1_000_000) as u32,
            )
            .ok_or("ok")
        }
    }
    struct TelemetryWrapper {
        session_id: ArrayString<40>,
        commit_hash: ArrayString<40>,
        #[serde(with = "UtcMillis")]
        timestamp: DateTime,
        payload: QuizResponse,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TelemetryWrapper {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "session_id" => _serde::__private::Ok(__Field::__field0),
                            "commit_hash" => _serde::__private::Ok(__Field::__field1),
                            "timestamp" => _serde::__private::Ok(__Field::__field2),
                            "payload" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"session_id" => _serde::__private::Ok(__Field::__field0),
                            b"commit_hash" => _serde::__private::Ok(__Field::__field1),
                            b"timestamp" => _serde::__private::Ok(__Field::__field2),
                            b"payload" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TelemetryWrapper>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TelemetryWrapper;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct TelemetryWrapper",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<ArrayString<40>>(
                            &mut __seq,
                        )? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct TelemetryWrapper with 4 elements",
                                ))
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<ArrayString<40>>(
                            &mut __seq,
                        )? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct TelemetryWrapper with 4 elements",
                                ))
                            }
                        };
                        let __field2 = match {
                            #[doc(hidden)]
                            struct __DeserializeWith<'de> {
                                value: DateTime,
                                phantom: _serde::__private::PhantomData<TelemetryWrapper>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            impl<'de> _serde::Deserialize<'de> for __DeserializeWith<'de> {
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::__private::Ok(__DeserializeWith {
                                        value: UtcMillis::deserialize(__deserializer)?,
                                        phantom: _serde::__private::PhantomData,
                                        lifetime: _serde::__private::PhantomData,
                                    })
                                }
                            }
                            _serde::__private::Option::map(
                                _serde::de::SeqAccess::next_element::<__DeserializeWith<'de>>(
                                    &mut __seq,
                                )?,
                                |__wrap| __wrap.value,
                            )
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct TelemetryWrapper with 4 elements",
                                ))
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<QuizResponse>(
                            &mut __seq,
                        )? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    3usize,
                                    &"struct TelemetryWrapper with 4 elements",
                                ))
                            }
                        };
                        _serde::__private::Ok(TelemetryWrapper {
                            session_id: __field0,
                            commit_hash: __field1,
                            timestamp: __field2,
                            payload: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<ArrayString<40>> =
                            _serde::__private::None;
                        let mut __field1: _serde::__private::Option<ArrayString<40>> =
                            _serde::__private::None;
                        let mut __field2: _serde::__private::Option<DateTime> =
                            _serde::__private::None;
                        let mut __field3: _serde::__private::Option<QuizResponse> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            _serde::de::MapAccess::next_key::<__Field>(&mut __map)?
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "session_id",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<ArrayString<40>>(
                                            &mut __map,
                                        )?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "commit_hash",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<ArrayString<40>>(
                                            &mut __map,
                                        )?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "timestamp",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some({
                                        #[doc(hidden)]
                                        struct __DeserializeWith<'de> {
                                            value: DateTime,
                                            phantom:
                                                _serde::__private::PhantomData<TelemetryWrapper>,
                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                        }
                                        impl<'de> _serde::Deserialize<'de> for __DeserializeWith<'de> {
                                            fn deserialize<__D>(
                                                __deserializer: __D,
                                            ) -> _serde::__private::Result<Self, __D::Error>
                                            where
                                                __D: _serde::Deserializer<'de>,
                                            {
                                                _serde::__private::Ok(__DeserializeWith {
                                                    value: UtcMillis::deserialize(__deserializer)?,
                                                    phantom: _serde::__private::PhantomData,
                                                    lifetime: _serde::__private::PhantomData,
                                                })
                                            }
                                        }
                                        match _serde::de::MapAccess::next_value::<
                                            __DeserializeWith<'de>,
                                        >(&mut __map)
                                        {
                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    });
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "payload",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<QuizResponse>(
                                            &mut __map,
                                        )?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("session_id")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("commit_hash")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    <__A::Error as _serde::de::Error>::missing_field("timestamp"),
                                )
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("payload")?
                            }
                        };
                        _serde::__private::Ok(TelemetryWrapper {
                            session_id: __field0,
                            commit_hash: __field1,
                            timestamp: __field2,
                            payload: __field3,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] =
                    &["session_id", "commit_hash", "timestamp", "payload"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TelemetryWrapper",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TelemetryWrapper>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for TelemetryWrapper {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "TelemetryWrapper",
                "session_id",
                &self.session_id,
                "commit_hash",
                &self.commit_hash,
                "timestamp",
                &self.timestamp,
                "payload",
                &&self.payload,
            )
        }
    }
    #[serde(rename_all = "camelCase")]
    struct QuizResponse {
        quiz_name: ArrayString<60>,
        quiz_hash: ArrayString<32>,
        answers: SmallVec<[QuestionResponse; 4]>,
        attempt: Option<usize>,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for QuizResponse {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "quizName" => _serde::__private::Ok(__Field::__field0),
                            "quizHash" => _serde::__private::Ok(__Field::__field1),
                            "answers" => _serde::__private::Ok(__Field::__field2),
                            "attempt" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"quizName" => _serde::__private::Ok(__Field::__field0),
                            b"quizHash" => _serde::__private::Ok(__Field::__field1),
                            b"answers" => _serde::__private::Ok(__Field::__field2),
                            b"attempt" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<QuizResponse>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = QuizResponse;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "struct QuizResponse")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<ArrayString<60>>(
                            &mut __seq,
                        )? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct QuizResponse with 4 elements",
                                ))
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<ArrayString<32>>(
                            &mut __seq,
                        )? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct QuizResponse with 4 elements",
                                ))
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            SmallVec<[QuestionResponse; 4]>,
                        >(&mut __seq)?
                        {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct QuizResponse with 4 elements",
                                ))
                            }
                        };
                        let __field3 =
                            match _serde::de::SeqAccess::next_element::<Option<usize>>(&mut __seq)?
                            {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct QuizResponse with 4 elements",
                                        ),
                                    )
                                }
                            };
                        _serde::__private::Ok(QuizResponse {
                            quiz_name: __field0,
                            quiz_hash: __field1,
                            answers: __field2,
                            attempt: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<ArrayString<60>> =
                            _serde::__private::None;
                        let mut __field1: _serde::__private::Option<ArrayString<32>> =
                            _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            SmallVec<[QuestionResponse; 4]>,
                        > = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<Option<usize>> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            _serde::de::MapAccess::next_key::<__Field>(&mut __map)?
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "quizName",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<ArrayString<60>>(
                                            &mut __map,
                                        )?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "quizHash",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<ArrayString<32>>(
                                            &mut __map,
                                        )?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "answers",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            SmallVec<[QuestionResponse; 4]>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "attempt",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Option<usize>>(
                                            &mut __map,
                                        )?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("quizName")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("quizHash")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("answers")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("attempt")?
                            }
                        };
                        _serde::__private::Ok(QuizResponse {
                            quiz_name: __field0,
                            quiz_hash: __field1,
                            answers: __field2,
                            attempt: __field3,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] =
                    &["quizName", "quizHash", "answers", "attempt"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "QuizResponse",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<QuizResponse>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for QuizResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "QuizResponse",
                "quiz_name",
                &self.quiz_name,
                "quiz_hash",
                &self.quiz_hash,
                "answers",
                &self.answers,
                "attempt",
                &&self.attempt,
            )
        }
    }
    struct QuestionResponse {
        answer: serde_json::Value,
        correct: bool,
        start: Option<DateTime>,
        end: Option<DateTime>,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for QuestionResponse {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "answer" => _serde::__private::Ok(__Field::__field0),
                            "correct" => _serde::__private::Ok(__Field::__field1),
                            "start" => _serde::__private::Ok(__Field::__field2),
                            "end" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"answer" => _serde::__private::Ok(__Field::__field0),
                            b"correct" => _serde::__private::Ok(__Field::__field1),
                            b"start" => _serde::__private::Ok(__Field::__field2),
                            b"end" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<QuestionResponse>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = QuestionResponse;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct QuestionResponse",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<serde_json::Value>(
                            &mut __seq,
                        )? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct QuestionResponse with 4 elements",
                                ))
                            }
                        };
                        let __field1 =
                            match _serde::de::SeqAccess::next_element::<bool>(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct QuestionResponse with 4 elements",
                                        ),
                                    )
                                }
                            };
                        let __field2 = match _serde::de::SeqAccess::next_element::<Option<DateTime>>(
                            &mut __seq,
                        )? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct QuestionResponse with 4 elements",
                                ))
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<Option<DateTime>>(
                            &mut __seq,
                        )? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    3usize,
                                    &"struct QuestionResponse with 4 elements",
                                ))
                            }
                        };
                        _serde::__private::Ok(QuestionResponse {
                            answer: __field0,
                            correct: __field1,
                            start: __field2,
                            end: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<serde_json::Value> =
                            _serde::__private::None;
                        let mut __field1: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Option<DateTime>> =
                            _serde::__private::None;
                        let mut __field3: _serde::__private::Option<Option<DateTime>> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            _serde::de::MapAccess::next_key::<__Field>(&mut __map)?
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "answer",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<serde_json::Value>(
                                            &mut __map,
                                        )?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "correct",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "start",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Option<DateTime>>(
                                            &mut __map,
                                        )?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "end",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Option<DateTime>>(
                                            &mut __map,
                                        )?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("answer")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("correct")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("start")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => _serde::__private::de::missing_field("end")?,
                        };
                        _serde::__private::Ok(QuestionResponse {
                            answer: __field0,
                            correct: __field1,
                            start: __field2,
                            end: __field3,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["answer", "correct", "start", "end"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "QuestionResponse",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<QuestionResponse>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for QuestionResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "QuestionResponse",
                "answer",
                &self.answer,
                "correct",
                &self.correct,
                "start",
                &self.start,
                "end",
                &&self.end,
            )
        }
    }
    fn analyze_inner() -> Result<()> {
        let conn = sqlite::open("../data/log.sqlite")?;
        let mut stmt = conn.prepare("SELECT data FROM answers")?;
        let raw_data = stmt
            .into_iter()
            .map(|res| {
                let sql_row = res?;
                let data = sql_row.read::<&[u8], _>("data");
                Ok(data.to_vec())
            })
            .collect::<sqlite::Result<Vec<_>>>()?;
        let rows = raw_data
            .into_iter()
            .map(|data| {
                let mut s = String::new();
                let mut z = ZlibDecoder::new(data.as_slice());
                z.read_to_string(&mut s)?;
                let quiz_response: TelemetryWrapper =
                    serde_json::from_str(&s).with_context(|| {
                        let mut s = String::new();
                        ZlibDecoder::new(data.as_slice())
                            .read_to_string(&mut s)
                            .unwrap();
                        let v: serde_json::Value = serde_json::from_str(&s).unwrap();
                        serde_json::to_string_pretty(&v).unwrap()
                    })?;
                Ok(quiz_response)
            })
            .collect::<Result<Vec<_>>>()?;
        Ok(())
    }
    pub fn analyze() -> PyResult<()> {
        Ok(analyze_inner()?)
    }
    #[doc(hidden)]
    pub mod analyze {
        pub(crate) struct MakeDef;
        pub const DEF: ::pyo3::impl_::pyfunction::PyMethodDef = MakeDef::DEF;
    }
    const _: () = {
        use :: pyo3 as _pyo3;
        impl analyze::MakeDef {
            const DEF: ::pyo3::impl_::pyfunction::PyMethodDef =
                _pyo3::impl_::pymethods::PyMethodDef::noargs(
                    "analyze\0",
                    _pyo3::impl_::pymethods::PyCFunction({
                        unsafe extern "C" fn trampoline(
                            _slf: *mut _pyo3::ffi::PyObject,
                            _args: *mut _pyo3::ffi::PyObject,
                        ) -> *mut _pyo3::ffi::PyObject {
                            _pyo3::impl_::trampoline::noargs(_slf, _args, __pyfunction_analyze)
                        }
                        trampoline
                    }),
                    "analyze()\n--\n\n\0",
                );
        }
        #[allow(non_snake_case)]
        unsafe fn __pyfunction_analyze<'py>(
            py: _pyo3::Python<'py>,
            _slf: *mut _pyo3::ffi::PyObject,
        ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
            let function = analyze;
            _pyo3::impl_::pymethods::OkWrap::wrap(function(), py)
                .map_err(::core::convert::Into::into)
                .map(_pyo3::IntoPyPointer::into_ptr)
        }
    };
}
mod quizzes {
    use anyhow::{Context, Result};
    use indicatif::ParallelProgressIterator;
    use internment::Arena;
    use itertools::Itertools;
    use pyo3::exceptions::PyException;
    use pyo3::prelude::*;
    use rayon::prelude::*;
    use serde::{Deserialize, Serialize};
    use std::collections::{hash_map::DefaultHasher, HashMap};
    use std::hash::{Hash, Hasher};
    use std::path::Path;
    use thread_local::ThreadLocal;
    type Commits = HashMap<String, HashMap<String, (u64, usize)>>;
    pub struct Quizzes {
        schemas: HashMap<u64, PyObject>,
        commits: Commits,
        ignored_inputs: Vec<usize>,
    }
    const _: () = {
        use :: pyo3 as _pyo3;
        unsafe impl _pyo3::type_object::PyTypeInfo for Quizzes {
            type AsRefTarget = _pyo3::PyCell<Self>;
            const NAME: &'static str = "Quizzes";
            const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
            #[inline]
            fn type_object_raw(py: _pyo3::Python<'_>) -> *mut _pyo3::ffi::PyTypeObject {
                <Quizzes as _pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                    .get_or_init(py)
                    .as_type_ptr()
            }
        }
        impl _pyo3::PyClass for Quizzes {
            type Frozen = _pyo3::pyclass::boolean_struct::False;
        }
        impl<'a, 'py> _pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py> for &'a Quizzes {
            type Holder = ::std::option::Option<_pyo3::PyRef<'py, Quizzes>>;
            #[inline]
            fn extract(
                obj: &'py _pyo3::PyAny,
                holder: &'a mut Self::Holder,
            ) -> _pyo3::PyResult<Self> {
                _pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
            }
        }
        impl<'a, 'py> _pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py> for &'a mut Quizzes {
            type Holder = ::std::option::Option<_pyo3::PyRefMut<'py, Quizzes>>;
            #[inline]
            fn extract(
                obj: &'py _pyo3::PyAny,
                holder: &'a mut Self::Holder,
            ) -> _pyo3::PyResult<Self> {
                _pyo3::impl_::extract_argument::extract_pyclass_ref_mut(obj, holder)
            }
        }
        impl _pyo3::IntoPy<_pyo3::PyObject> for Quizzes {
            fn into_py(self, py: _pyo3::Python) -> _pyo3::PyObject {
                _pyo3::IntoPy::into_py(_pyo3::Py::new(py, self).unwrap(), py)
            }
        }
        impl _pyo3::impl_::pyclass::PyClassImpl for Quizzes {
            const IS_BASETYPE: bool = false;
            const IS_SUBCLASS: bool = false;
            const IS_MAPPING: bool = false;
            const IS_SEQUENCE: bool = false;
            type Layout = _pyo3::PyCell<Self>;
            type BaseType = _pyo3::PyAny;
            type ThreadChecker = _pyo3::impl_::pyclass::ThreadCheckerStub<Quizzes>;
            type PyClassMutability = < < _pyo3 :: PyAny as _pyo3 :: impl_ :: pyclass :: PyClassBaseType > :: PyClassMutability as _pyo3 :: impl_ :: pycell :: PyClassMutability > :: MutableChild ;
            type Dict = _pyo3::impl_::pyclass::PyClassDummySlot;
            type WeakRef = _pyo3::impl_::pyclass::PyClassDummySlot;
            type BaseNativeType = _pyo3::PyAny;
            fn items_iter() -> _pyo3::impl_::pyclass::PyClassItemsIter {
                use _pyo3::impl_::pyclass::*;
                let collector = PyClassImplCollector::<Self>::new();
                static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                    methods: &[],
                    slots: &[],
                };
                PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
            }
            fn doc(py: _pyo3::Python<'_>) -> _pyo3::PyResult<&'static ::std::ffi::CStr> {
                use _pyo3::impl_::pyclass::*;
                static DOC: _pyo3::once_cell::GILOnceCell<
                    ::std::borrow::Cow<'static, ::std::ffi::CStr>,
                > = _pyo3::once_cell::GILOnceCell::new();
                DOC.get_or_try_init(py, || {
                    let collector = PyClassImplCollector::<Self>::new();
                    build_pyclass_doc(
                        <Quizzes as _pyo3::PyTypeInfo>::NAME,
                        "\0",
                        ::std::option::Option::None.or_else(|| collector.new_text_signature()),
                    )
                })
                .map(::std::ops::Deref::deref)
            }
            fn lazy_type_object() -> &'static _pyo3::impl_::pyclass::LazyTypeObject<Self> {
                use _pyo3::impl_::pyclass::LazyTypeObject;
                static TYPE_OBJECT: LazyTypeObject<Quizzes> = LazyTypeObject::new();
                &TYPE_OBJECT
            }
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        impl Quizzes {}
    };
    const RUST_BOOK_DIR: &str = "../code/rust-book";
    struct Schema {
        questions: Vec<Question>,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Schema {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "Schema",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "questions",
                    &self.questions,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Schema {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "questions" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"questions" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Schema>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Schema;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "struct Schema")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 =
                            match _serde::de::SeqAccess::next_element::<Vec<Question>>(&mut __seq)?
                            {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Schema with 1 element",
                                        ),
                                    )
                                }
                            };
                        _serde::__private::Ok(Schema {
                            questions: __field0,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<Vec<Question>> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            _serde::de::MapAccess::next_key::<__Field>(&mut __map)?
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "questions",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Vec<Question>>(
                                            &mut __map,
                                        )?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("questions")?
                            }
                        };
                        _serde::__private::Ok(Schema {
                            questions: __field0,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["questions"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Schema",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Schema>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for Schema {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "Schema",
                "questions",
                &&self.questions,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Schema {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Schema {
        #[inline]
        fn eq(&self, other: &Schema) -> bool {
            self.questions == other.questions
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Schema {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Schema {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Vec<Question>>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Schema {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.questions, state)
        }
    }
    enum QuestionType {
        Tracing,
        MultipleChoice,
        ShortAnswer,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for QuestionType {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    QuestionType::Tracing => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "QuestionType",
                        0u32,
                        "Tracing",
                    ),
                    QuestionType::MultipleChoice => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "QuestionType",
                        1u32,
                        "MultipleChoice",
                    ),
                    QuestionType::ShortAnswer => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "QuestionType",
                        2u32,
                        "ShortAnswer",
                    ),
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for QuestionType {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 3",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Tracing" => _serde::__private::Ok(__Field::__field0),
                            "MultipleChoice" => _serde::__private::Ok(__Field::__field1),
                            "ShortAnswer" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Tracing" => _serde::__private::Ok(__Field::__field0),
                            b"MultipleChoice" => _serde::__private::Ok(__Field::__field1),
                            b"ShortAnswer" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<QuestionType>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = QuestionType;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "enum QuestionType")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(QuestionType::Tracing)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(QuestionType::MultipleChoice)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(QuestionType::ShortAnswer)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] =
                    &["Tracing", "MultipleChoice", "ShortAnswer"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "QuestionType",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<QuestionType>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for QuestionType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    QuestionType::Tracing => "Tracing",
                    QuestionType::MultipleChoice => "MultipleChoice",
                    QuestionType::ShortAnswer => "ShortAnswer",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for QuestionType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for QuestionType {
        #[inline]
        fn eq(&self, other: &QuestionType) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for QuestionType {}
    #[automatically_derived]
    impl ::core::cmp::Eq for QuestionType {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for QuestionType {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state)
        }
    }
    #[serde(untagged)]
    enum MultipleChoice {
        MultipleChoiceNew(MultipleChoiceNew),
        MultipleChoiceOld(MultipleChoiceOld),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for MultipleChoice {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    MultipleChoice::MultipleChoiceNew(ref __field0) => {
                        _serde::Serialize::serialize(__field0, __serializer)
                    }
                    MultipleChoice::MultipleChoiceOld(ref __field0) => {
                        _serde::Serialize::serialize(__field0, __serializer)
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for MultipleChoice {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                let __content =
                    <_serde::__private::de::Content as _serde::Deserialize>::deserialize(
                        __deserializer,
                    )?;
                let __deserializer =
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content);
                if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                    <MultipleChoiceNew as _serde::Deserialize>::deserialize(__deserializer),
                    MultipleChoice::MultipleChoiceNew,
                ) {
                    return _serde::__private::Ok(__ok);
                }
                if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                    <MultipleChoiceOld as _serde::Deserialize>::deserialize(__deserializer),
                    MultipleChoice::MultipleChoiceOld,
                ) {
                    return _serde::__private::Ok(__ok);
                }
                _serde::__private::Err(_serde::de::Error::custom(
                    "data did not match any variant of untagged enum MultipleChoice",
                ))
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for MultipleChoice {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                MultipleChoice::MultipleChoiceNew(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "MultipleChoiceNew",
                        &__self_0,
                    )
                }
                MultipleChoice::MultipleChoiceOld(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "MultipleChoiceOld",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for MultipleChoice {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for MultipleChoice {
        #[inline]
        fn eq(&self, other: &MultipleChoice) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (
                        MultipleChoice::MultipleChoiceNew(__self_0),
                        MultipleChoice::MultipleChoiceNew(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        MultipleChoice::MultipleChoiceOld(__self_0),
                        MultipleChoice::MultipleChoiceOld(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() },
                }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for MultipleChoice {}
    #[automatically_derived]
    impl ::core::cmp::Eq for MultipleChoice {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<MultipleChoiceNew>;
            let _: ::core::cmp::AssertParamIsEq<MultipleChoiceOld>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for MultipleChoice {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                MultipleChoice::MultipleChoiceNew(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                MultipleChoice::MultipleChoiceOld(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
            }
        }
    }
    struct MultipleChoiceNew {
        id: Option<String>,
        prompt: MultipleChoicePrompt,
        answer: MultipleChoiceAnswer,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for MultipleChoiceNew {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "MultipleChoiceNew",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(&mut __serde_state, "id", &self.id)?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "prompt",
                    &self.prompt,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "answer",
                    &self.answer,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for MultipleChoiceNew {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "id" => _serde::__private::Ok(__Field::__field0),
                            "prompt" => _serde::__private::Ok(__Field::__field1),
                            "answer" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"id" => _serde::__private::Ok(__Field::__field0),
                            b"prompt" => _serde::__private::Ok(__Field::__field1),
                            b"answer" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<MultipleChoiceNew>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = MultipleChoiceNew;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct MultipleChoiceNew",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<Option<String>>(
                            &mut __seq,
                        )? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct MultipleChoiceNew with 3 elements",
                                ))
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            MultipleChoicePrompt,
                        >(&mut __seq)?
                        {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct MultipleChoiceNew with 3 elements",
                                ))
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            MultipleChoiceAnswer,
                        >(&mut __seq)?
                        {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct MultipleChoiceNew with 3 elements",
                                ))
                            }
                        };
                        _serde::__private::Ok(MultipleChoiceNew {
                            id: __field0,
                            prompt: __field1,
                            answer: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<Option<String>> =
                            _serde::__private::None;
                        let mut __field1: _serde::__private::Option<MultipleChoicePrompt> =
                            _serde::__private::None;
                        let mut __field2: _serde::__private::Option<MultipleChoiceAnswer> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            _serde::de::MapAccess::next_key::<__Field>(&mut __map)?
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "id",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Option<String>>(
                                            &mut __map,
                                        )?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "prompt",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<MultipleChoicePrompt>(
                                            &mut __map,
                                        )?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "answer",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<MultipleChoiceAnswer>(
                                            &mut __map,
                                        )?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => _serde::__private::de::missing_field("id")?,
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("prompt")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("answer")?
                            }
                        };
                        _serde::__private::Ok(MultipleChoiceNew {
                            id: __field0,
                            prompt: __field1,
                            answer: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["id", "prompt", "answer"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "MultipleChoiceNew",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<MultipleChoiceNew>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for MultipleChoiceNew {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "MultipleChoiceNew",
                "id",
                &self.id,
                "prompt",
                &self.prompt,
                "answer",
                &&self.answer,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for MultipleChoiceNew {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for MultipleChoiceNew {
        #[inline]
        fn eq(&self, other: &MultipleChoiceNew) -> bool {
            self.id == other.id && self.prompt == other.prompt && self.answer == other.answer
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for MultipleChoiceNew {}
    #[automatically_derived]
    impl ::core::cmp::Eq for MultipleChoiceNew {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<String>>;
            let _: ::core::cmp::AssertParamIsEq<MultipleChoicePrompt>;
            let _: ::core::cmp::AssertParamIsEq<MultipleChoiceAnswer>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for MultipleChoiceNew {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.id, state);
            ::core::hash::Hash::hash(&self.prompt, state);
            ::core::hash::Hash::hash(&self.answer, state)
        }
    }
    struct MultipleChoicePrompt {
        prompt: String,
        distractors: Vec<String>,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for MultipleChoicePrompt {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "MultipleChoicePrompt",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "prompt",
                    &self.prompt,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "distractors",
                    &self.distractors,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for MultipleChoicePrompt {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "prompt" => _serde::__private::Ok(__Field::__field0),
                            "distractors" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"prompt" => _serde::__private::Ok(__Field::__field0),
                            b"distractors" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<MultipleChoicePrompt>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = MultipleChoicePrompt;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct MultipleChoicePrompt",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 =
                            match _serde::de::SeqAccess::next_element::<String>(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct MultipleChoicePrompt with 2 elements",
                                        ),
                                    )
                                }
                            };
                        let __field1 =
                            match _serde::de::SeqAccess::next_element::<Vec<String>>(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct MultipleChoicePrompt with 2 elements",
                                        ),
                                    )
                                }
                            };
                        _serde::__private::Ok(MultipleChoicePrompt {
                            prompt: __field0,
                            distractors: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> =
                            _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Vec<String>> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            _serde::de::MapAccess::next_key::<__Field>(&mut __map)?
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "prompt",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "distractors",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Vec<String>>(
                                            &mut __map,
                                        )?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("prompt")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("distractors")?
                            }
                        };
                        _serde::__private::Ok(MultipleChoicePrompt {
                            prompt: __field0,
                            distractors: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["prompt", "distractors"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "MultipleChoicePrompt",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<MultipleChoicePrompt>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for MultipleChoicePrompt {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "MultipleChoicePrompt",
                "prompt",
                &self.prompt,
                "distractors",
                &&self.distractors,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for MultipleChoicePrompt {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for MultipleChoicePrompt {
        #[inline]
        fn eq(&self, other: &MultipleChoicePrompt) -> bool {
            self.prompt == other.prompt && self.distractors == other.distractors
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for MultipleChoicePrompt {}
    #[automatically_derived]
    impl ::core::cmp::Eq for MultipleChoicePrompt {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<String>;
            let _: ::core::cmp::AssertParamIsEq<Vec<String>>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for MultipleChoicePrompt {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.prompt, state);
            ::core::hash::Hash::hash(&self.distractors, state)
        }
    }
    struct MultipleChoiceAnswer {
        answer: MultipleChoiceAnswerOptions,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for MultipleChoiceAnswer {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "MultipleChoiceAnswer",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "answer",
                    &self.answer,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for MultipleChoiceAnswer {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "answer" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"answer" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<MultipleChoiceAnswer>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = MultipleChoiceAnswer;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct MultipleChoiceAnswer",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            MultipleChoiceAnswerOptions,
                        >(&mut __seq)?
                        {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct MultipleChoiceAnswer with 1 element",
                                ))
                            }
                        };
                        _serde::__private::Ok(MultipleChoiceAnswer { answer: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<MultipleChoiceAnswerOptions> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            _serde::de::MapAccess::next_key::<__Field>(&mut __map)?
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "answer",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            MultipleChoiceAnswerOptions,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("answer")?
                            }
                        };
                        _serde::__private::Ok(MultipleChoiceAnswer { answer: __field0 })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["answer"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "MultipleChoiceAnswer",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<MultipleChoiceAnswer>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for MultipleChoiceAnswer {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "MultipleChoiceAnswer",
                "answer",
                &&self.answer,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for MultipleChoiceAnswer {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for MultipleChoiceAnswer {
        #[inline]
        fn eq(&self, other: &MultipleChoiceAnswer) -> bool {
            self.answer == other.answer
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for MultipleChoiceAnswer {}
    #[automatically_derived]
    impl ::core::cmp::Eq for MultipleChoiceAnswer {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<MultipleChoiceAnswerOptions>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for MultipleChoiceAnswer {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.answer, state)
        }
    }
    #[serde(untagged)]
    enum MultipleChoiceAnswerOptions {
        Single(String),
        Multiple(Vec<String>),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for MultipleChoiceAnswerOptions {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    MultipleChoiceAnswerOptions::Single(ref __field0) => {
                        _serde::Serialize::serialize(__field0, __serializer)
                    }
                    MultipleChoiceAnswerOptions::Multiple(ref __field0) => {
                        _serde::Serialize::serialize(__field0, __serializer)
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for MultipleChoiceAnswerOptions {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                let __content =
                    <_serde::__private::de::Content as _serde::Deserialize>::deserialize(
                        __deserializer,
                    )?;
                let __deserializer =
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content);
                if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                    <String as _serde::Deserialize>::deserialize(__deserializer),
                    MultipleChoiceAnswerOptions::Single,
                ) {
                    return _serde::__private::Ok(__ok);
                }
                if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                    <Vec<String> as _serde::Deserialize>::deserialize(__deserializer),
                    MultipleChoiceAnswerOptions::Multiple,
                ) {
                    return _serde::__private::Ok(__ok);
                }
                _serde::__private::Err(_serde::de::Error::custom(
                    "data did not match any variant of untagged enum MultipleChoiceAnswerOptions",
                ))
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for MultipleChoiceAnswerOptions {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                MultipleChoiceAnswerOptions::Single(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Single", &__self_0)
                }
                MultipleChoiceAnswerOptions::Multiple(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Multiple", &__self_0)
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for MultipleChoiceAnswerOptions {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for MultipleChoiceAnswerOptions {
        #[inline]
        fn eq(&self, other: &MultipleChoiceAnswerOptions) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (
                        MultipleChoiceAnswerOptions::Single(__self_0),
                        MultipleChoiceAnswerOptions::Single(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        MultipleChoiceAnswerOptions::Multiple(__self_0),
                        MultipleChoiceAnswerOptions::Multiple(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() },
                }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for MultipleChoiceAnswerOptions {}
    #[automatically_derived]
    impl ::core::cmp::Eq for MultipleChoiceAnswerOptions {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<String>;
            let _: ::core::cmp::AssertParamIsEq<Vec<String>>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for MultipleChoiceAnswerOptions {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                MultipleChoiceAnswerOptions::Single(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                MultipleChoiceAnswerOptions::Multiple(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
            }
        }
    }
    struct MultipleChoiceOld {
        id: Option<String>,
        prompt: MultipleChoiceOldPrompt,
        answer: MultipleChoiceOldAnswer,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for MultipleChoiceOld {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "MultipleChoiceOld",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(&mut __serde_state, "id", &self.id)?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "prompt",
                    &self.prompt,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "answer",
                    &self.answer,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for MultipleChoiceOld {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "id" => _serde::__private::Ok(__Field::__field0),
                            "prompt" => _serde::__private::Ok(__Field::__field1),
                            "answer" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"id" => _serde::__private::Ok(__Field::__field0),
                            b"prompt" => _serde::__private::Ok(__Field::__field1),
                            b"answer" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<MultipleChoiceOld>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = MultipleChoiceOld;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct MultipleChoiceOld",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<Option<String>>(
                            &mut __seq,
                        )? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct MultipleChoiceOld with 3 elements",
                                ))
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            MultipleChoiceOldPrompt,
                        >(&mut __seq)?
                        {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct MultipleChoiceOld with 3 elements",
                                ))
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            MultipleChoiceOldAnswer,
                        >(&mut __seq)?
                        {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct MultipleChoiceOld with 3 elements",
                                ))
                            }
                        };
                        _serde::__private::Ok(MultipleChoiceOld {
                            id: __field0,
                            prompt: __field1,
                            answer: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<Option<String>> =
                            _serde::__private::None;
                        let mut __field1: _serde::__private::Option<MultipleChoiceOldPrompt> =
                            _serde::__private::None;
                        let mut __field2: _serde::__private::Option<MultipleChoiceOldAnswer> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            _serde::de::MapAccess::next_key::<__Field>(&mut __map)?
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "id",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Option<String>>(
                                            &mut __map,
                                        )?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "prompt",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<MultipleChoiceOldPrompt>(
                                            &mut __map,
                                        )?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "answer",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<MultipleChoiceOldAnswer>(
                                            &mut __map,
                                        )?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => _serde::__private::de::missing_field("id")?,
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("prompt")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("answer")?
                            }
                        };
                        _serde::__private::Ok(MultipleChoiceOld {
                            id: __field0,
                            prompt: __field1,
                            answer: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["id", "prompt", "answer"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "MultipleChoiceOld",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<MultipleChoiceOld>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for MultipleChoiceOld {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "MultipleChoiceOld",
                "id",
                &self.id,
                "prompt",
                &self.prompt,
                "answer",
                &&self.answer,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for MultipleChoiceOld {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for MultipleChoiceOld {
        #[inline]
        fn eq(&self, other: &MultipleChoiceOld) -> bool {
            self.id == other.id && self.prompt == other.prompt && self.answer == other.answer
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for MultipleChoiceOld {}
    #[automatically_derived]
    impl ::core::cmp::Eq for MultipleChoiceOld {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<String>>;
            let _: ::core::cmp::AssertParamIsEq<MultipleChoiceOldPrompt>;
            let _: ::core::cmp::AssertParamIsEq<MultipleChoiceOldAnswer>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for MultipleChoiceOld {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.id, state);
            ::core::hash::Hash::hash(&self.prompt, state);
            ::core::hash::Hash::hash(&self.answer, state)
        }
    }
    struct MultipleChoiceOldPrompt {
        prompt: String,
        choices: Vec<String>,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for MultipleChoiceOldPrompt {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "MultipleChoiceOldPrompt",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "prompt",
                    &self.prompt,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "choices",
                    &self.choices,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for MultipleChoiceOldPrompt {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "prompt" => _serde::__private::Ok(__Field::__field0),
                            "choices" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"prompt" => _serde::__private::Ok(__Field::__field0),
                            b"choices" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<MultipleChoiceOldPrompt>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = MultipleChoiceOldPrompt;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct MultipleChoiceOldPrompt",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 =
                            match _serde::de::SeqAccess::next_element::<String>(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct MultipleChoiceOldPrompt with 2 elements",
                                        ),
                                    )
                                }
                            };
                        let __field1 =
                            match _serde::de::SeqAccess::next_element::<Vec<String>>(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct MultipleChoiceOldPrompt with 2 elements",
                                        ),
                                    )
                                }
                            };
                        _serde::__private::Ok(MultipleChoiceOldPrompt {
                            prompt: __field0,
                            choices: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> =
                            _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Vec<String>> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            _serde::de::MapAccess::next_key::<__Field>(&mut __map)?
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "prompt",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "choices",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Vec<String>>(
                                            &mut __map,
                                        )?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("prompt")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("choices")?
                            }
                        };
                        _serde::__private::Ok(MultipleChoiceOldPrompt {
                            prompt: __field0,
                            choices: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["prompt", "choices"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "MultipleChoiceOldPrompt",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<MultipleChoiceOldPrompt>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for MultipleChoiceOldPrompt {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "MultipleChoiceOldPrompt",
                "prompt",
                &self.prompt,
                "choices",
                &&self.choices,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for MultipleChoiceOldPrompt {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for MultipleChoiceOldPrompt {
        #[inline]
        fn eq(&self, other: &MultipleChoiceOldPrompt) -> bool {
            self.prompt == other.prompt && self.choices == other.choices
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for MultipleChoiceOldPrompt {}
    #[automatically_derived]
    impl ::core::cmp::Eq for MultipleChoiceOldPrompt {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<String>;
            let _: ::core::cmp::AssertParamIsEq<Vec<String>>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for MultipleChoiceOldPrompt {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.prompt, state);
            ::core::hash::Hash::hash(&self.choices, state)
        }
    }
    struct MultipleChoiceOldAnswer {
        answer: usize,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for MultipleChoiceOldAnswer {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "MultipleChoiceOldAnswer",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "answer",
                    &self.answer,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for MultipleChoiceOldAnswer {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "answer" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"answer" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<MultipleChoiceOldAnswer>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = MultipleChoiceOldAnswer;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct MultipleChoiceOldAnswer",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 =
                            match _serde::de::SeqAccess::next_element::<usize>(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct MultipleChoiceOldAnswer with 1 element",
                                        ),
                                    )
                                }
                            };
                        _serde::__private::Ok(MultipleChoiceOldAnswer { answer: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<usize> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            _serde::de::MapAccess::next_key::<__Field>(&mut __map)?
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "answer",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<usize>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("answer")?
                            }
                        };
                        _serde::__private::Ok(MultipleChoiceOldAnswer { answer: __field0 })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["answer"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "MultipleChoiceOldAnswer",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<MultipleChoiceOldAnswer>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for MultipleChoiceOldAnswer {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "MultipleChoiceOldAnswer",
                "answer",
                &&self.answer,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for MultipleChoiceOldAnswer {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for MultipleChoiceOldAnswer {
        #[inline]
        fn eq(&self, other: &MultipleChoiceOldAnswer) -> bool {
            self.answer == other.answer
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for MultipleChoiceOldAnswer {}
    #[automatically_derived]
    impl ::core::cmp::Eq for MultipleChoiceOldAnswer {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<usize>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for MultipleChoiceOldAnswer {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.answer, state)
        }
    }
    struct ShortAnswer {
        id: Option<String>,
        prompt: ShortAnswerPrompt,
        answer: ShortAnswerAnswer,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ShortAnswer {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ShortAnswer",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(&mut __serde_state, "id", &self.id)?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "prompt",
                    &self.prompt,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "answer",
                    &self.answer,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ShortAnswer {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "id" => _serde::__private::Ok(__Field::__field0),
                            "prompt" => _serde::__private::Ok(__Field::__field1),
                            "answer" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"id" => _serde::__private::Ok(__Field::__field0),
                            b"prompt" => _serde::__private::Ok(__Field::__field1),
                            b"answer" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ShortAnswer>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ShortAnswer;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "struct ShortAnswer")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<Option<String>>(
                            &mut __seq,
                        )? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct ShortAnswer with 3 elements",
                                ))
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<ShortAnswerPrompt>(
                            &mut __seq,
                        )? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct ShortAnswer with 3 elements",
                                ))
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<ShortAnswerAnswer>(
                            &mut __seq,
                        )? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct ShortAnswer with 3 elements",
                                ))
                            }
                        };
                        _serde::__private::Ok(ShortAnswer {
                            id: __field0,
                            prompt: __field1,
                            answer: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<Option<String>> =
                            _serde::__private::None;
                        let mut __field1: _serde::__private::Option<ShortAnswerPrompt> =
                            _serde::__private::None;
                        let mut __field2: _serde::__private::Option<ShortAnswerAnswer> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            _serde::de::MapAccess::next_key::<__Field>(&mut __map)?
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "id",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Option<String>>(
                                            &mut __map,
                                        )?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "prompt",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<ShortAnswerPrompt>(
                                            &mut __map,
                                        )?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "answer",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<ShortAnswerAnswer>(
                                            &mut __map,
                                        )?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => _serde::__private::de::missing_field("id")?,
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("prompt")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("answer")?
                            }
                        };
                        _serde::__private::Ok(ShortAnswer {
                            id: __field0,
                            prompt: __field1,
                            answer: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["id", "prompt", "answer"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ShortAnswer",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ShortAnswer>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for ShortAnswer {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "ShortAnswer",
                "id",
                &self.id,
                "prompt",
                &self.prompt,
                "answer",
                &&self.answer,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ShortAnswer {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ShortAnswer {
        #[inline]
        fn eq(&self, other: &ShortAnswer) -> bool {
            self.id == other.id && self.prompt == other.prompt && self.answer == other.answer
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for ShortAnswer {}
    #[automatically_derived]
    impl ::core::cmp::Eq for ShortAnswer {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<String>>;
            let _: ::core::cmp::AssertParamIsEq<ShortAnswerPrompt>;
            let _: ::core::cmp::AssertParamIsEq<ShortAnswerAnswer>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for ShortAnswer {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.id, state);
            ::core::hash::Hash::hash(&self.prompt, state);
            ::core::hash::Hash::hash(&self.answer, state)
        }
    }
    struct ShortAnswerPrompt {
        prompt: String,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ShortAnswerPrompt {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ShortAnswerPrompt",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "prompt",
                    &self.prompt,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ShortAnswerPrompt {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "prompt" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"prompt" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ShortAnswerPrompt>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ShortAnswerPrompt;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ShortAnswerPrompt",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 =
                            match _serde::de::SeqAccess::next_element::<String>(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct ShortAnswerPrompt with 1 element",
                                        ),
                                    )
                                }
                            };
                        _serde::__private::Ok(ShortAnswerPrompt { prompt: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            _serde::de::MapAccess::next_key::<__Field>(&mut __map)?
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "prompt",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("prompt")?
                            }
                        };
                        _serde::__private::Ok(ShortAnswerPrompt { prompt: __field0 })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["prompt"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ShortAnswerPrompt",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ShortAnswerPrompt>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for ShortAnswerPrompt {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "ShortAnswerPrompt",
                "prompt",
                &&self.prompt,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ShortAnswerPrompt {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ShortAnswerPrompt {
        #[inline]
        fn eq(&self, other: &ShortAnswerPrompt) -> bool {
            self.prompt == other.prompt
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for ShortAnswerPrompt {}
    #[automatically_derived]
    impl ::core::cmp::Eq for ShortAnswerPrompt {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<String>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for ShortAnswerPrompt {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.prompt, state)
        }
    }
    struct ShortAnswerAnswer {
        answer: String,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ShortAnswerAnswer {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ShortAnswerAnswer",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "answer",
                    &self.answer,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ShortAnswerAnswer {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "answer" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"answer" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ShortAnswerAnswer>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ShortAnswerAnswer;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ShortAnswerAnswer",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 =
                            match _serde::de::SeqAccess::next_element::<String>(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct ShortAnswerAnswer with 1 element",
                                        ),
                                    )
                                }
                            };
                        _serde::__private::Ok(ShortAnswerAnswer { answer: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            _serde::de::MapAccess::next_key::<__Field>(&mut __map)?
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "answer",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("answer")?
                            }
                        };
                        _serde::__private::Ok(ShortAnswerAnswer { answer: __field0 })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["answer"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ShortAnswerAnswer",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ShortAnswerAnswer>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for ShortAnswerAnswer {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "ShortAnswerAnswer",
                "answer",
                &&self.answer,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ShortAnswerAnswer {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ShortAnswerAnswer {
        #[inline]
        fn eq(&self, other: &ShortAnswerAnswer) -> bool {
            self.answer == other.answer
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for ShortAnswerAnswer {}
    #[automatically_derived]
    impl ::core::cmp::Eq for ShortAnswerAnswer {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<String>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for ShortAnswerAnswer {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.answer, state)
        }
    }
    struct Tracing {
        id: Option<String>,
        prompt: TracingPrompt,
        answer: TracingAnswer,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Tracing {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "Tracing",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(&mut __serde_state, "id", &self.id)?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "prompt",
                    &self.prompt,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "answer",
                    &self.answer,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Tracing {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "id" => _serde::__private::Ok(__Field::__field0),
                            "prompt" => _serde::__private::Ok(__Field::__field1),
                            "answer" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"id" => _serde::__private::Ok(__Field::__field0),
                            b"prompt" => _serde::__private::Ok(__Field::__field1),
                            b"answer" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Tracing>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Tracing;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "struct Tracing")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<Option<String>>(
                            &mut __seq,
                        )? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct Tracing with 3 elements",
                                ))
                            }
                        };
                        let __field1 =
                            match _serde::de::SeqAccess::next_element::<TracingPrompt>(&mut __seq)?
                            {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Tracing with 3 elements",
                                        ),
                                    )
                                }
                            };
                        let __field2 =
                            match _serde::de::SeqAccess::next_element::<TracingAnswer>(&mut __seq)?
                            {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct Tracing with 3 elements",
                                        ),
                                    )
                                }
                            };
                        _serde::__private::Ok(Tracing {
                            id: __field0,
                            prompt: __field1,
                            answer: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<Option<String>> =
                            _serde::__private::None;
                        let mut __field1: _serde::__private::Option<TracingPrompt> =
                            _serde::__private::None;
                        let mut __field2: _serde::__private::Option<TracingAnswer> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            _serde::de::MapAccess::next_key::<__Field>(&mut __map)?
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "id",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Option<String>>(
                                            &mut __map,
                                        )?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "prompt",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<TracingPrompt>(
                                            &mut __map,
                                        )?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "answer",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<TracingAnswer>(
                                            &mut __map,
                                        )?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => _serde::__private::de::missing_field("id")?,
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("prompt")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("answer")?
                            }
                        };
                        _serde::__private::Ok(Tracing {
                            id: __field0,
                            prompt: __field1,
                            answer: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["id", "prompt", "answer"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Tracing",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Tracing>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for Tracing {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Tracing",
                "id",
                &self.id,
                "prompt",
                &self.prompt,
                "answer",
                &&self.answer,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Tracing {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Tracing {
        #[inline]
        fn eq(&self, other: &Tracing) -> bool {
            self.id == other.id && self.prompt == other.prompt && self.answer == other.answer
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Tracing {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Tracing {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<String>>;
            let _: ::core::cmp::AssertParamIsEq<TracingPrompt>;
            let _: ::core::cmp::AssertParamIsEq<TracingAnswer>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Tracing {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.id, state);
            ::core::hash::Hash::hash(&self.prompt, state);
            ::core::hash::Hash::hash(&self.answer, state)
        }
    }
    struct TracingPrompt {
        program: String,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TracingPrompt {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "TracingPrompt",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "program",
                    &self.program,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TracingPrompt {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "program" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"program" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TracingPrompt>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TracingPrompt;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "struct TracingPrompt")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 =
                            match _serde::de::SeqAccess::next_element::<String>(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct TracingPrompt with 1 element",
                                        ),
                                    )
                                }
                            };
                        _serde::__private::Ok(TracingPrompt { program: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            _serde::de::MapAccess::next_key::<__Field>(&mut __map)?
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "program",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("program")?
                            }
                        };
                        _serde::__private::Ok(TracingPrompt { program: __field0 })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["program"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TracingPrompt",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TracingPrompt>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for TracingPrompt {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "TracingPrompt",
                "program",
                &&self.program,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TracingPrompt {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TracingPrompt {
        #[inline]
        fn eq(&self, other: &TracingPrompt) -> bool {
            self.program == other.program
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for TracingPrompt {}
    #[automatically_derived]
    impl ::core::cmp::Eq for TracingPrompt {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<String>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for TracingPrompt {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.program, state)
        }
    }
    #[serde(untagged)]
    enum TracingAnswer {
        DoesNotCompile {
            #[serde(rename = "doesCompile")]
            does_compile: bool,
            #[serde(rename = "lineNumber")]
            line_number: usize,
        },
        DoesCompile {
            #[serde(rename = "doesCompile")]
            does_compile: bool,
            stdout: String,
        },
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TracingAnswer {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    TracingAnswer::DoesNotCompile {
                        ref does_compile,
                        ref line_number,
                    } => {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "TracingAnswer",
                            0 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "doesCompile",
                            does_compile,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "lineNumber",
                            line_number,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                    TracingAnswer::DoesCompile {
                        ref does_compile,
                        ref stdout,
                    } => {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "TracingAnswer",
                            0 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "doesCompile",
                            does_compile,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "stdout",
                            stdout,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TracingAnswer {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                let __content =
                    <_serde::__private::de::Content as _serde::Deserialize>::deserialize(
                        __deserializer,
                    )?;
                let __deserializer =
                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content);
                if let _serde::__private::Ok(__ok) = {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "doesCompile" => _serde::__private::Ok(__Field::__field0),
                                "lineNumber" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"doesCompile" => _serde::__private::Ok(__Field::__field0),
                                b"lineNumber" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<TracingAnswer>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = TracingAnswer;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct variant TracingAnswer::DoesNotCompile",
                            )
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<bool> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<usize> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                _serde::de::MapAccess::next_key::<__Field>(&mut __map)?
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "doesCompile",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "lineNumber",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<usize>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        )?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("doesCompile")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("lineNumber")?
                                }
                            };
                            _serde::__private::Ok(TracingAnswer::DoesNotCompile {
                                does_compile: __field0,
                                line_number: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["doesCompile", "lineNumber"];
                    _serde::Deserializer::deserialize_any(
                        __deserializer,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<TracingAnswer>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                } {
                    return _serde::__private::Ok(__ok);
                }
                if let _serde::__private::Ok(__ok) = {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "doesCompile" => _serde::__private::Ok(__Field::__field0),
                                "stdout" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"doesCompile" => _serde::__private::Ok(__Field::__field0),
                                b"stdout" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<TracingAnswer>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = TracingAnswer;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct variant TracingAnswer::DoesCompile",
                            )
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<bool> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                _serde::de::MapAccess::next_key::<__Field>(&mut __map)?
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "doesCompile",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "stdout",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            )?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        )?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("doesCompile")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("stdout")?
                                }
                            };
                            _serde::__private::Ok(TracingAnswer::DoesCompile {
                                does_compile: __field0,
                                stdout: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["doesCompile", "stdout"];
                    _serde::Deserializer::deserialize_any(
                        __deserializer,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<TracingAnswer>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                } {
                    return _serde::__private::Ok(__ok);
                }
                _serde::__private::Err(_serde::de::Error::custom(
                    "data did not match any variant of untagged enum TracingAnswer",
                ))
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for TracingAnswer {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                TracingAnswer::DoesNotCompile {
                    does_compile: __self_0,
                    line_number: __self_1,
                } => ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "DoesNotCompile",
                    "does_compile",
                    __self_0,
                    "line_number",
                    &__self_1,
                ),
                TracingAnswer::DoesCompile {
                    does_compile: __self_0,
                    stdout: __self_1,
                } => ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "DoesCompile",
                    "does_compile",
                    __self_0,
                    "stdout",
                    &__self_1,
                ),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TracingAnswer {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TracingAnswer {
        #[inline]
        fn eq(&self, other: &TracingAnswer) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (
                        TracingAnswer::DoesNotCompile {
                            does_compile: __self_0,
                            line_number: __self_1,
                        },
                        TracingAnswer::DoesNotCompile {
                            does_compile: __arg1_0,
                            line_number: __arg1_1,
                        },
                    ) => *__self_0 == *__arg1_0 && *__self_1 == *__arg1_1,
                    (
                        TracingAnswer::DoesCompile {
                            does_compile: __self_0,
                            stdout: __self_1,
                        },
                        TracingAnswer::DoesCompile {
                            does_compile: __arg1_0,
                            stdout: __arg1_1,
                        },
                    ) => *__self_0 == *__arg1_0 && *__self_1 == *__arg1_1,
                    _ => unsafe { ::core::intrinsics::unreachable() },
                }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for TracingAnswer {}
    #[automatically_derived]
    impl ::core::cmp::Eq for TracingAnswer {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<bool>;
            let _: ::core::cmp::AssertParamIsEq<usize>;
            let _: ::core::cmp::AssertParamIsEq<String>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for TracingAnswer {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                TracingAnswer::DoesNotCompile {
                    does_compile: __self_0,
                    line_number: __self_1,
                } => {
                    ::core::hash::Hash::hash(__self_0, state);
                    ::core::hash::Hash::hash(__self_1, state)
                }
                TracingAnswer::DoesCompile {
                    does_compile: __self_0,
                    stdout: __self_1,
                } => {
                    ::core::hash::Hash::hash(__self_0, state);
                    ::core::hash::Hash::hash(__self_1, state)
                }
            }
        }
    }
    #[serde(tag = "type")]
    enum Question {
        MultipleChoice(MultipleChoice),
        ShortAnswer(ShortAnswer),
        Tracing(Tracing),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Question {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Question::MultipleChoice(ref __field0) => {
                        _serde::__private::ser::serialize_tagged_newtype(
                            __serializer,
                            "Question",
                            "MultipleChoice",
                            "type",
                            "MultipleChoice",
                            __field0,
                        )
                    }
                    Question::ShortAnswer(ref __field0) => {
                        _serde::__private::ser::serialize_tagged_newtype(
                            __serializer,
                            "Question",
                            "ShortAnswer",
                            "type",
                            "ShortAnswer",
                            __field0,
                        )
                    }
                    Question::Tracing(ref __field0) => {
                        _serde::__private::ser::serialize_tagged_newtype(
                            __serializer,
                            "Question",
                            "Tracing",
                            "type",
                            "Tracing",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Question {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 3",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "MultipleChoice" => _serde::__private::Ok(__Field::__field0),
                            "ShortAnswer" => _serde::__private::Ok(__Field::__field1),
                            "Tracing" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"MultipleChoice" => _serde::__private::Ok(__Field::__field0),
                            b"ShortAnswer" => _serde::__private::Ok(__Field::__field1),
                            b"Tracing" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] =
                    &["MultipleChoice", "ShortAnswer", "Tracing"];
                let (__tag, __content) = _serde::Deserializer::deserialize_any(
                    __deserializer,
                    _serde::__private::de::TaggedContentVisitor::<__Field>::new(
                        "type",
                        "internally tagged enum Question",
                    ),
                )?;
                let __deserializer =
                    _serde::__private::de::ContentDeserializer::<__D::Error>::new(__content);
                match __tag {
                    __Field::__field0 => _serde::__private::Result::map(
                        <MultipleChoice as _serde::Deserialize>::deserialize(__deserializer),
                        Question::MultipleChoice,
                    ),
                    __Field::__field1 => _serde::__private::Result::map(
                        <ShortAnswer as _serde::Deserialize>::deserialize(__deserializer),
                        Question::ShortAnswer,
                    ),
                    __Field::__field2 => _serde::__private::Result::map(
                        <Tracing as _serde::Deserialize>::deserialize(__deserializer),
                        Question::Tracing,
                    ),
                }
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for Question {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                Question::MultipleChoice(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "MultipleChoice",
                        &__self_0,
                    )
                }
                Question::ShortAnswer(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f, "ShortAnswer", &__self_0)
                }
                Question::Tracing(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Tracing", &__self_0)
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Question {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Question {
        #[inline]
        fn eq(&self, other: &Question) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (Question::MultipleChoice(__self_0), Question::MultipleChoice(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Question::ShortAnswer(__self_0), Question::ShortAnswer(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Question::Tracing(__self_0), Question::Tracing(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    _ => unsafe { ::core::intrinsics::unreachable() },
                }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Question {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Question {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<MultipleChoice>;
            let _: ::core::cmp::AssertParamIsEq<ShortAnswer>;
            let _: ::core::cmp::AssertParamIsEq<Tracing>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Question {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                Question::MultipleChoice(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Question::ShortAnswer(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Question::Tracing(__self_0) => ::core::hash::Hash::hash(__self_0, state),
            }
        }
    }
    impl Quizzes {
        fn build(py: Python, answers: Vec<(String, String)>) -> Result<Self> {
            let rust_book_dir = &Path::new(RUST_BOOK_DIR).canonicalize()?;
            let schema_arena: Arena<Schema> = Arena::new();
            let schemas = {
                let repo_tl: ThreadLocal<git2::Repository> = ThreadLocal::new();
                let answers_copy = answers.into_iter().enumerate().collect::<Vec<_>>();
                let load_schema = |(index, (name, commit_hash)): (usize, (String, String))| {
                    let repo = repo_tl.get_or(|| {
                        git2::Repository::open(rust_book_dir)
                            .expect("Failed to initialize git repo")
                    });
                    let schema = {
                        let obj_spec = {
                            let res = ::alloc::fmt::format(format_args!(
                                "{0}:quizzes/{1}.toml",
                                commit_hash, name
                            ));
                            res
                        };
                        let Ok(obj) = repo.revparse_single(&obj_spec) else {
                            return Ok(Err(index));
                        };
                        let blob = obj.peel_to_blob()?;
                        let s = String::from_utf8_lossy(blob.content());
                        toml::from_str::<Schema>(&*s).with_context(|| s.to_string())?
                    };
                    let schema = schema_arena.intern(schema);
                    let time = {
                        let obj = repo.revparse_single(&commit_hash)?;
                        let commit = obj.peel_to_commit()?;
                        commit.time().seconds()
                    };
                    let content_hash = {
                        let mut hasher = DefaultHasher::new();
                        schema.hash(&mut hasher);
                        hasher.finish()
                    };
                    Ok(Ok((name, (time, content_hash, commit_hash, schema))))
                };
                answers_copy
                    .into_par_iter()
                    .progress()
                    .map(load_schema)
                    .collect::<Result<Vec<_>>>()?
            };
            let (ignored, schemas): (Vec<_>, Vec<_>) =
                schemas.into_iter().partition(|res| res.is_err());
            let ignored_inputs = ignored
                .into_iter()
                .map(|res| res.unwrap_err())
                .collect::<Vec<_>>();
            if let Some(usage) = memory_stats::memory_stats() {
                {
                    ::std::io::_print(format_args!(
                        "Current physical memory usage: {0} MB\n",
                        usage.physical_mem / 1024 / 1024
                    ));
                };
            }
            let groups = schemas
                .into_iter()
                .map(|schema| schema.unwrap())
                .into_group_map();
            let mut schemas = HashMap::new();
            let mut commits: Commits = HashMap::new();
            for (name, mut v) in groups {
                v.sort_by_key(|(time, ..)| *time);
                for (_, content_hash, commit_hash, schema) in v {
                    let new_schema = !schemas.contains_key(&content_hash);
                    if new_schema {
                        schemas.insert(content_hash, pythonize::pythonize(py, &*schema)?);
                    }
                    let quiz_commits = commits.entry(name.clone()).or_default();
                    let last_version = quiz_commits
                        .values()
                        .map(|(_, version)| *version)
                        .max()
                        .unwrap_or(0);
                    let version = if new_schema {
                        last_version + 1
                    } else {
                        last_version
                    };
                    quiz_commits.insert(commit_hash, (content_hash, version));
                }
            }
            if let Some(usage) = memory_stats::memory_stats() {
                {
                    ::std::io::_print(format_args!(
                        "Current physical memory usage: {0} MB\n",
                        usage.physical_mem / 1024 / 1024
                    ));
                };
            }
            Ok(Quizzes {
                schemas,
                commits,
                ignored_inputs,
            })
        }
    }
    impl Quizzes {
        fn py_new(py: Python, answers: Vec<(String, String)>) -> PyResult<Self> {
            Self::build(py, answers).map_err(|e| {
                PyException::new_err({
                    let res = ::alloc::fmt::format(format_args!("{0:?}", e));
                    res
                })
            })
        }
        fn schema(&self, py: Python, quiz_name: &str, commit_hash: &str) -> PyObject {
            let (content_hash, _) = &self.commits[quiz_name][commit_hash];
            Py::clone_ref(&self.schemas[&content_hash], py)
        }
        fn version(&self, quiz_name: &str, commit_hash: &str) -> PyResult<usize> {
            let (_, version) = &self.commits[quiz_name].get(commit_hash).ok_or_else(|| {
                PyException::new_err({
                    let res = ::alloc::fmt::format(format_args!(
                        "Missing {0} at {1}",
                        quiz_name, commit_hash
                    ));
                    res
                })
            })?;
            Ok(*version)
        }
        fn ignored_inputs(&self) -> Vec<usize> {
            self.ignored_inputs.clone()
        }
    }
    const _: () = {
        use :: pyo3 as _pyo3;
        impl _pyo3::impl_::pyclass::PyMethods<Quizzes>
            for _pyo3::impl_::pyclass::PyClassImplCollector<Quizzes>
        {
            fn py_methods(self) -> &'static _pyo3::impl_::pyclass::PyClassItems {
                static ITEMS : _pyo3 :: impl_ :: pyclass :: PyClassItems = _pyo3 :: impl_ :: pyclass :: PyClassItems { methods : & [_pyo3 :: class :: PyMethodDefType :: Method (_pyo3 :: impl_ :: pymethods :: PyMethodDef :: fastcall_cfunction_with_keywords ("schema\0" , _pyo3 :: impl_ :: pymethods :: PyCFunctionFastWithKeywords ({ unsafe extern "C" fn trampoline (_slf : * mut _pyo3 :: ffi :: PyObject , _args : * const * mut _pyo3 :: ffi :: PyObject , _nargs : _pyo3 :: ffi :: Py_ssize_t , _kwnames : * mut _pyo3 :: ffi :: PyObject) -> * mut _pyo3 :: ffi :: PyObject { _pyo3 :: impl_ :: trampoline :: fastcall_with_keywords (_slf , _args , _nargs , _kwnames , Quizzes :: __pymethod_schema__) } trampoline }) , "schema($self, quiz_name, commit_hash)\n--\n\n\0")) , _pyo3 :: class :: PyMethodDefType :: Method (_pyo3 :: impl_ :: pymethods :: PyMethodDef :: fastcall_cfunction_with_keywords ("version\0" , _pyo3 :: impl_ :: pymethods :: PyCFunctionFastWithKeywords ({ unsafe extern "C" fn trampoline (_slf : * mut _pyo3 :: ffi :: PyObject , _args : * const * mut _pyo3 :: ffi :: PyObject , _nargs : _pyo3 :: ffi :: Py_ssize_t , _kwnames : * mut _pyo3 :: ffi :: PyObject) -> * mut _pyo3 :: ffi :: PyObject { _pyo3 :: impl_ :: trampoline :: fastcall_with_keywords (_slf , _args , _nargs , _kwnames , Quizzes :: __pymethod_version__) } trampoline }) , "version($self, quiz_name, commit_hash)\n--\n\n\0")) , _pyo3 :: class :: PyMethodDefType :: Method (_pyo3 :: impl_ :: pymethods :: PyMethodDef :: noargs ("ignored_inputs\0" , _pyo3 :: impl_ :: pymethods :: PyCFunction ({ unsafe extern "C" fn trampoline (_slf : * mut _pyo3 :: ffi :: PyObject , _args : * mut _pyo3 :: ffi :: PyObject) -> * mut _pyo3 :: ffi :: PyObject { _pyo3 :: impl_ :: trampoline :: noargs (_slf , _args , Quizzes :: __pymethod_ignored_inputs__) } trampoline }) , "ignored_inputs($self)\n--\n\n\0"))] , slots : & [_pyo3 :: ffi :: PyType_Slot { slot : _pyo3 :: ffi :: Py_tp_new , pfunc : { unsafe extern "C" fn trampoline (subtype : * mut _pyo3 :: ffi :: PyTypeObject , args : * mut _pyo3 :: ffi :: PyObject , kwargs : * mut _pyo3 :: ffi :: PyObject) -> * mut _pyo3 :: ffi :: PyObject { use _pyo3 :: impl_ :: pyclass :: * ; impl PyClassNewTextSignature < Quizzes > for PyClassImplCollector < Quizzes > { # [inline] fn new_text_signature (self) -> :: std :: option :: Option < & 'static str > { :: std :: option :: Option :: Some ("(answers)") } } _pyo3 :: impl_ :: trampoline :: newfunc (subtype , args , kwargs , Quizzes :: __pymethod___new____) } trampoline } as _pyo3 :: ffi :: newfunc as _ , }] , } ;
                &ITEMS
            }
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        impl Quizzes {
            unsafe fn __pymethod___new____(
                py: _pyo3::Python<'_>,
                subtype: *mut _pyo3::ffi::PyTypeObject,
                _args: *mut _pyo3::ffi::PyObject,
                _kwargs: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
                use _pyo3::callback::IntoPyCallbackOutput;
                let function = Quizzes::py_new;
                const DESCRIPTION: _pyo3::impl_::extract_argument::FunctionDescription =
                    _pyo3::impl_::extract_argument::FunctionDescription {
                        cls_name: ::std::option::Option::Some(
                            <Quizzes as _pyo3::type_object::PyTypeInfo>::NAME,
                        ),
                        func_name: "__new__",
                        positional_parameter_names: &["answers"],
                        positional_only_parameters: 0usize,
                        required_positional_parameters: 1usize,
                        keyword_only_parameters: &[],
                    };
                let mut output = [::std::option::Option::None; 1usize];
                let (_args , _kwargs) = DESCRIPTION . extract_arguments_tuple_dict :: < _pyo3 :: impl_ :: extract_argument :: NoVarargs , _pyo3 :: impl_ :: extract_argument :: NoVarkeywords > (py , _args , _kwargs , & mut output) ? ;
                let result = Quizzes::py_new(
                    py,
                    _pyo3::impl_::extract_argument::extract_argument(
                        _pyo3::impl_::extract_argument::unwrap_required_argument(output[0usize]),
                        &mut { _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT },
                        "answers",
                    )?,
                );
                let initializer: _pyo3::PyClassInitializer<Quizzes> = result.convert(py)?;
                let cell = initializer.create_cell_from_subtype(py, subtype)?;
                ::std::result::Result::Ok(cell as *mut _pyo3::ffi::PyObject)
            }
            unsafe fn __pymethod_schema__<'py>(
                py: _pyo3::Python<'py>,
                _slf: *mut _pyo3::ffi::PyObject,
                _args: *const *mut _pyo3::ffi::PyObject,
                _nargs: _pyo3::ffi::Py_ssize_t,
                _kwnames: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
                let function = Quizzes::schema;
                const DESCRIPTION: _pyo3::impl_::extract_argument::FunctionDescription =
                    _pyo3::impl_::extract_argument::FunctionDescription {
                        cls_name: ::std::option::Option::Some(
                            <Quizzes as _pyo3::type_object::PyTypeInfo>::NAME,
                        ),
                        func_name: "schema",
                        positional_parameter_names: &["quiz_name", "commit_hash"],
                        positional_only_parameters: 0usize,
                        required_positional_parameters: 2usize,
                        keyword_only_parameters: &[],
                    };
                let mut output = [::std::option::Option::None; 2usize];
                let (_args , _kwargs) = DESCRIPTION . extract_arguments_fastcall :: < _pyo3 :: impl_ :: extract_argument :: NoVarargs , _pyo3 :: impl_ :: extract_argument :: NoVarkeywords > (py , _args , _nargs , _kwnames , & mut output) ? ;
                _pyo3::impl_::pymethods::OkWrap::wrap(
                    function(
                        _pyo3::impl_::extract_argument::extract_pyclass_ref::<Quizzes>(
                            py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                            &mut { _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT },
                        )?,
                        py,
                        _pyo3::impl_::extract_argument::extract_argument(
                            _pyo3::impl_::extract_argument::unwrap_required_argument(
                                output[0usize],
                            ),
                            &mut { _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT },
                            "quiz_name",
                        )?,
                        _pyo3::impl_::extract_argument::extract_argument(
                            _pyo3::impl_::extract_argument::unwrap_required_argument(
                                output[1usize],
                            ),
                            &mut { _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT },
                            "commit_hash",
                        )?,
                    ),
                    py,
                )
                .map_err(::core::convert::Into::into)
                .map(_pyo3::IntoPyPointer::into_ptr)
            }
            unsafe fn __pymethod_version__<'py>(
                py: _pyo3::Python<'py>,
                _slf: *mut _pyo3::ffi::PyObject,
                _args: *const *mut _pyo3::ffi::PyObject,
                _nargs: _pyo3::ffi::Py_ssize_t,
                _kwnames: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
                let function = Quizzes::version;
                const DESCRIPTION: _pyo3::impl_::extract_argument::FunctionDescription =
                    _pyo3::impl_::extract_argument::FunctionDescription {
                        cls_name: ::std::option::Option::Some(
                            <Quizzes as _pyo3::type_object::PyTypeInfo>::NAME,
                        ),
                        func_name: "version",
                        positional_parameter_names: &["quiz_name", "commit_hash"],
                        positional_only_parameters: 0usize,
                        required_positional_parameters: 2usize,
                        keyword_only_parameters: &[],
                    };
                let mut output = [::std::option::Option::None; 2usize];
                let (_args , _kwargs) = DESCRIPTION . extract_arguments_fastcall :: < _pyo3 :: impl_ :: extract_argument :: NoVarargs , _pyo3 :: impl_ :: extract_argument :: NoVarkeywords > (py , _args , _nargs , _kwnames , & mut output) ? ;
                _pyo3::impl_::pymethods::OkWrap::wrap(
                    function(
                        _pyo3::impl_::extract_argument::extract_pyclass_ref::<Quizzes>(
                            py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                            &mut { _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT },
                        )?,
                        _pyo3::impl_::extract_argument::extract_argument(
                            _pyo3::impl_::extract_argument::unwrap_required_argument(
                                output[0usize],
                            ),
                            &mut { _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT },
                            "quiz_name",
                        )?,
                        _pyo3::impl_::extract_argument::extract_argument(
                            _pyo3::impl_::extract_argument::unwrap_required_argument(
                                output[1usize],
                            ),
                            &mut { _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT },
                            "commit_hash",
                        )?,
                    ),
                    py,
                )
                .map_err(::core::convert::Into::into)
                .map(_pyo3::IntoPyPointer::into_ptr)
            }
            unsafe fn __pymethod_ignored_inputs__<'py>(
                py: _pyo3::Python<'py>,
                _slf: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
                let function = Quizzes::ignored_inputs;
                _pyo3::impl_::pymethods::OkWrap::wrap(
                    function(_pyo3::impl_::extract_argument::extract_pyclass_ref::<
                        Quizzes,
                    >(
                        py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                        &mut { _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT },
                    )?),
                    py,
                )
                .map_err(::core::convert::Into::into)
                .map(_pyo3::IntoPyPointer::into_ptr)
            }
        }
    };
}
mod token {
    use anyhow::{anyhow, Result};
    use markdown::mdast::Node;
    use proc_macro2::{TokenStream, TokenTree};
    use pyo3::prelude::*;
    use std::str::FromStr;
    fn count_rust_tokens_internal(s: &str) -> Result<usize> {
        let stream = TokenStream::from_str(s).map_err(|e| {
            ::anyhow::__private::must_use({
                let error = ::anyhow::__private::format_err(format_args!("{0}", e));
                error
            })
        })?;
        fn count(stream: TokenStream) -> usize {
            stream
                .into_iter()
                .map(|tree| match tree {
                    TokenTree::Group(g) => count(g.stream()) + 2,
                    _ => 1,
                })
                .sum()
        }
        Ok(count(stream))
    }
    fn count_md_tokens_internal(s: &str) -> Result<usize> {
        let root = markdown::to_mdast(s, &markdown::ParseOptions::default()).map_err(|s| {
            ::anyhow::__private::must_use({
                let error = ::anyhow::__private::format_err(format_args!("{0}", s));
                error
            })
        })?;
        fn collect_nodes(root: &Node) -> Vec<&Node> {
            let mut queue = <[_]>::into_vec(
                #[rustc_box]
                ::alloc::boxed::Box::new([root]),
            );
            let mut nodes = ::alloc::vec::Vec::new();
            while let Some(node) = queue.pop() {
                nodes.push(node);
                if let Some(children) = node.children() {
                    queue.extend(children);
                }
            }
            nodes
        }
        let nodes = collect_nodes(&root);
        let mut count = 0;
        for node in nodes {
            let n = match node {
                Node::Text(text) => text.value.split(" ").count(),
                Node::Code(code) => match code.lang.as_ref().map(|s| s.as_str()) {
                    None | Some("ide") | Some("rust") => count_rust_tokens_internal(&code.value)?,
                    _ => code.value.split(" ").count(),
                },
                _ => 0,
            };
            count += n;
        }
        Ok(count)
    }
    pub fn count_rust_tokens(s: &str) -> PyResult<usize> {
        Ok(count_rust_tokens_internal(s)?)
    }
    #[doc(hidden)]
    pub mod count_rust_tokens {
        pub(crate) struct MakeDef;
        pub const DEF: ::pyo3::impl_::pyfunction::PyMethodDef = MakeDef::DEF;
    }
    const _: () = {
        use :: pyo3 as _pyo3;
        impl count_rust_tokens::MakeDef {
            const DEF: ::pyo3::impl_::pyfunction::PyMethodDef =
                _pyo3::impl_::pymethods::PyMethodDef::fastcall_cfunction_with_keywords(
                    "count_rust_tokens\0",
                    _pyo3::impl_::pymethods::PyCFunctionFastWithKeywords({
                        unsafe extern "C" fn trampoline(
                            _slf: *mut _pyo3::ffi::PyObject,
                            _args: *const *mut _pyo3::ffi::PyObject,
                            _nargs: _pyo3::ffi::Py_ssize_t,
                            _kwnames: *mut _pyo3::ffi::PyObject,
                        ) -> *mut _pyo3::ffi::PyObject {
                            _pyo3::impl_::trampoline::fastcall_with_keywords(
                                _slf,
                                _args,
                                _nargs,
                                _kwnames,
                                __pyfunction_count_rust_tokens,
                            )
                        }
                        trampoline
                    }),
                    "count_rust_tokens(s)\n--\n\n\0",
                );
        }
        #[allow(non_snake_case)]
        unsafe fn __pyfunction_count_rust_tokens<'py>(
            py: _pyo3::Python<'py>,
            _slf: *mut _pyo3::ffi::PyObject,
            _args: *const *mut _pyo3::ffi::PyObject,
            _nargs: _pyo3::ffi::Py_ssize_t,
            _kwnames: *mut _pyo3::ffi::PyObject,
        ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
            let function = count_rust_tokens;
            const DESCRIPTION: _pyo3::impl_::extract_argument::FunctionDescription =
                _pyo3::impl_::extract_argument::FunctionDescription {
                    cls_name: ::std::option::Option::None,
                    func_name: "count_rust_tokens",
                    positional_parameter_names: &["s"],
                    positional_only_parameters: 0usize,
                    required_positional_parameters: 1usize,
                    keyword_only_parameters: &[],
                };
            let mut output = [::std::option::Option::None; 1usize];
            let (_args , _kwargs) = DESCRIPTION . extract_arguments_fastcall :: < _pyo3 :: impl_ :: extract_argument :: NoVarargs , _pyo3 :: impl_ :: extract_argument :: NoVarkeywords > (py , _args , _nargs , _kwnames , & mut output) ? ;
            _pyo3::impl_::pymethods::OkWrap::wrap(
                function(_pyo3::impl_::extract_argument::extract_argument(
                    _pyo3::impl_::extract_argument::unwrap_required_argument(output[0usize]),
                    &mut { _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT },
                    "s",
                )?),
                py,
            )
            .map_err(::core::convert::Into::into)
            .map(_pyo3::IntoPyPointer::into_ptr)
        }
    };
    pub fn count_md_tokens(s: &str) -> PyResult<usize> {
        Ok(count_md_tokens_internal(s)?)
    }
    #[doc(hidden)]
    pub mod count_md_tokens {
        pub(crate) struct MakeDef;
        pub const DEF: ::pyo3::impl_::pyfunction::PyMethodDef = MakeDef::DEF;
    }
    const _: () = {
        use :: pyo3 as _pyo3;
        impl count_md_tokens::MakeDef {
            const DEF: ::pyo3::impl_::pyfunction::PyMethodDef =
                _pyo3::impl_::pymethods::PyMethodDef::fastcall_cfunction_with_keywords(
                    "count_md_tokens\0",
                    _pyo3::impl_::pymethods::PyCFunctionFastWithKeywords({
                        unsafe extern "C" fn trampoline(
                            _slf: *mut _pyo3::ffi::PyObject,
                            _args: *const *mut _pyo3::ffi::PyObject,
                            _nargs: _pyo3::ffi::Py_ssize_t,
                            _kwnames: *mut _pyo3::ffi::PyObject,
                        ) -> *mut _pyo3::ffi::PyObject {
                            _pyo3::impl_::trampoline::fastcall_with_keywords(
                                _slf,
                                _args,
                                _nargs,
                                _kwnames,
                                __pyfunction_count_md_tokens,
                            )
                        }
                        trampoline
                    }),
                    "count_md_tokens(s)\n--\n\n\0",
                );
        }
        #[allow(non_snake_case)]
        unsafe fn __pyfunction_count_md_tokens<'py>(
            py: _pyo3::Python<'py>,
            _slf: *mut _pyo3::ffi::PyObject,
            _args: *const *mut _pyo3::ffi::PyObject,
            _nargs: _pyo3::ffi::Py_ssize_t,
            _kwnames: *mut _pyo3::ffi::PyObject,
        ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
            let function = count_md_tokens;
            const DESCRIPTION: _pyo3::impl_::extract_argument::FunctionDescription =
                _pyo3::impl_::extract_argument::FunctionDescription {
                    cls_name: ::std::option::Option::None,
                    func_name: "count_md_tokens",
                    positional_parameter_names: &["s"],
                    positional_only_parameters: 0usize,
                    required_positional_parameters: 1usize,
                    keyword_only_parameters: &[],
                };
            let mut output = [::std::option::Option::None; 1usize];
            let (_args , _kwargs) = DESCRIPTION . extract_arguments_fastcall :: < _pyo3 :: impl_ :: extract_argument :: NoVarargs , _pyo3 :: impl_ :: extract_argument :: NoVarkeywords > (py , _args , _nargs , _kwnames , & mut output) ? ;
            _pyo3::impl_::pymethods::OkWrap::wrap(
                function(_pyo3::impl_::extract_argument::extract_argument(
                    _pyo3::impl_::extract_argument::unwrap_required_argument(output[0usize]),
                    &mut { _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT },
                    "s",
                )?),
                py,
            )
            .map_err(::core::convert::Into::into)
            .map(_pyo3::IntoPyPointer::into_ptr)
        }
    };
}
fn rs_utils(_py: Python, m: &PyModule) -> PyResult<()> {
    m.add_class::<quizzes::Quizzes>()?;
    m.add_function({
        use token::count_md_tokens as wrapped_pyfunction;
        ::pyo3::impl_::pyfunction::_wrap_pyfunction(&wrapped_pyfunction::DEF, m)
    }?)?;
    m.add_function({
        use token::count_rust_tokens as wrapped_pyfunction;
        ::pyo3::impl_::pyfunction::_wrap_pyfunction(&wrapped_pyfunction::DEF, m)
    }?)?;
    m.add_function({
        use analysis::analyze as wrapped_pyfunction;
        ::pyo3::impl_::pyfunction::_wrap_pyfunction(&wrapped_pyfunction::DEF, m)
    }?)?;
    Ok(())
}
#[doc(hidden)]
mod rs_utils {
    pub(crate) struct MakeDef;
    pub static DEF: ::pyo3::impl_::pymodule::ModuleDef = MakeDef::make_def();
    pub const NAME: &'static str = "rs_utils\u{0}";
    /// This autogenerated function is called by the python interpreter when importing
    /// the module.
    #[export_name = "PyInit_rs_utils"]
    pub unsafe extern "C" fn init() -> *mut ::pyo3::ffi::PyObject {
        ::pyo3::impl_::trampoline::module_init(|py| DEF.make_module(py))
    }
}
const _: () = {
    use ::pyo3::impl_::pymodule as impl_;
    impl rs_utils::MakeDef {
        const fn make_def() -> impl_::ModuleDef {
            const INITIALIZER: impl_::ModuleInitializer = impl_::ModuleInitializer(rs_utils);
            unsafe { impl_::ModuleDef::new(rs_utils::NAME, "\0", INITIALIZER) }
        }
    }
};
